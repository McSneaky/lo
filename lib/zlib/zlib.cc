
// [do not edit,<auto-generated />]
// This file has been automatically generated, please do not change unless you disable auto-generation in the Makefile  
#include <zlib.h>
#include <stdint.h>
#include <stdlib.h>
#include <lo.h>

namespace lo {
namespace zlib {

using v8::String;
using v8::FunctionCallbackInfo;
using v8::Array;
using v8::Local;
using v8::ObjectTemplate;
using v8::Isolate;
using v8::Value;
using v8::Uint32Array;
using v8::ArrayBuffer;
using v8::Context;
using v8::Integer;
using v8::Function;
using v8::NewStringType;
using v8::Object;
using v8::BackingStore;
using v8::TryCatch;
using v8::ScriptCompiler;
using v8::Module;
using v8::FixedArray;
using v8::ScriptOrigin;
using v8::SharedArrayBuffer;
using v8::MaybeLocal;
using v8::HandleScope;
using v8::Promise;
using v8::Number;
using v8::StackTrace;
using v8::Message;
using v8::StackFrame;
using v8::Maybe;
using v8::FunctionTemplate;
using v8::FunctionCallback;
using v8::PromiseRejectMessage;
using v8::CFunction;
using v8::Global;
using v8::Exception;
using v8::CTypeInfo;
using v8::PropertyAttribute;
using v8::Signature;
using v8::ConstructorBehavior;
using v8::SideEffectType;
using v8::kPromiseRejectAfterResolved;
using v8::kPromiseResolveAfterResolved;
using v8::kPromiseHandlerAddedAfterReject;
using v8::Data;
using v8::PrimitiveArray;
using v8::TypedArray;
using v8::Uint8Array;
using v8::Boolean;
using v8::ModuleRequest;
using v8::CFunctionInfo;
using v8::OOMDetails;
using v8::V8;
using v8::BigInt;


#define Z_DEFAULT_MEMLEVEL 8

uint32_t zlib_deflate (uint8_t* src, uint32_t ssize, uint8_t* dest, uint32_t dsize) {
  z_stream* stream = (z_stream*)calloc(1, sizeof(z_stream));
  unsigned int compression = Z_DEFAULT_COMPRESSION;
  int windowbits = 31;
  deflateInit2(stream, compression, Z_DEFLATED, windowbits, Z_DEFAULT_MEMLEVEL, Z_DEFAULT_STRATEGY);
  stream->next_in = (Bytef*)src;
  stream->avail_in = ssize;
  stream->next_out = (Bytef*)dest;
  stream->avail_out = dsize;
  uint32_t avail_out = stream->avail_out;
  uint32_t flush = Z_FINISH;
  deflate(stream, flush);
  uint32_t written = avail_out - stream->avail_out;
  deflateEnd(stream);
  free(stream);
  return written;
}

// todo: this api is kinda nasty - fix it
uint32_t zlib_inflate (uint8_t* src, uint32_t ssize, uint8_t* dest, uint32_t dsize) {
  z_stream* stream = (z_stream*)calloc(1, sizeof(z_stream));
  int windowbits = 31;
  inflateInit2(stream, windowbits);
  stream->next_in = (Bytef*)src;
  stream->avail_in = ssize;
  stream->next_out = (Bytef*)dest;
  stream->avail_out = dsize;
  uint32_t avail_out = stream->avail_out;
  uint32_t flush = Z_FINISH;
  //fprintf(stderr, "before next_in %lu avail_in %u next_out %lu avail_out %u\n", (uint64_t)stream->next_in, stream->avail_in, (uint64_t)stream->next_out, stream->avail_out);
  inflate(stream, flush);
  //fprintf(stderr, "after next_in %lu avail_in %u next_out %lu avail_out %u, rc = %i\n", (uint64_t)stream->next_in, stream->avail_in, (uint64_t)stream->next_out, stream->avail_out, rc);
  uint32_t written = avail_out - stream->avail_out;
  inflateEnd(stream);
  free(stream);
  return written;
}  


uint32_t deflateFast(void* p, struct FastApiTypedArray* const p0, uint32_t p1, struct FastApiTypedArray* const p2, uint32_t p3);
v8::CTypeInfo cargsdeflate[5] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
};
v8::CTypeInfo rcdeflate = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
v8::CFunctionInfo infodeflate = v8::CFunctionInfo(rcdeflate, 5, cargsdeflate);
v8::CFunction pFdeflate = v8::CFunction((const void*)&deflateFast, &infodeflate);

uint32_t inflateFast(void* p, struct FastApiTypedArray* const p0, uint32_t p1, struct FastApiTypedArray* const p2, uint32_t p3);
v8::CTypeInfo cargsinflate[5] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
};
v8::CTypeInfo rcinflate = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
v8::CFunctionInfo infoinflate = v8::CFunctionInfo(rcinflate, 5, cargsinflate);
v8::CFunction pFinflate = v8::CFunction((const void*)&inflateFast, &infoinflate);



void deflateSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  uint8_t* v0 = reinterpret_cast<uint8_t*>(ptr0);
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  Local<Uint8Array> u82 = args[2].As<Uint8Array>();
  uint8_t* ptr2 = (uint8_t*)u82->Buffer()->Data() + u82->ByteOffset();
  uint8_t* v2 = reinterpret_cast<uint8_t*>(ptr2);
  uint32_t v3 = Local<Integer>::Cast(args[3])->Value();
  uint32_t rc = zlib_deflate(v0, v1, v2, v3);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

uint32_t deflateFast(void* p, struct FastApiTypedArray* const p0, uint32_t p1, struct FastApiTypedArray* const p2, uint32_t p3) {
  uint8_t* v0 = reinterpret_cast<uint8_t*>(p0->data);
  uint32_t v1 = p1;
  uint8_t* v2 = reinterpret_cast<uint8_t*>(p2->data);
  uint32_t v3 = p3;
  return zlib_deflate(v0, v1, v2, v3);
}
void inflateSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  uint8_t* v0 = reinterpret_cast<uint8_t*>(ptr0);
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  Local<Uint8Array> u82 = args[2].As<Uint8Array>();
  uint8_t* ptr2 = (uint8_t*)u82->Buffer()->Data() + u82->ByteOffset();
  uint8_t* v2 = reinterpret_cast<uint8_t*>(ptr2);
  uint32_t v3 = Local<Integer>::Cast(args[3])->Value();
  uint32_t rc = zlib_inflate(v0, v1, v2, v3);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

uint32_t inflateFast(void* p, struct FastApiTypedArray* const p0, uint32_t p1, struct FastApiTypedArray* const p2, uint32_t p3) {
  uint8_t* v0 = reinterpret_cast<uint8_t*>(p0->data);
  uint32_t v1 = p1;
  uint8_t* v2 = reinterpret_cast<uint8_t*>(p2->data);
  uint32_t v3 = p3;
  return zlib_inflate(v0, v1, v2, v3);
}

void Init(Isolate* isolate, Local<ObjectTemplate> target) {
  Local<ObjectTemplate> module = ObjectTemplate::New(isolate);
  SET_FAST_METHOD(isolate, module, "deflate", &pFdeflate, deflateSlow);
  SET_FAST_METHOD(isolate, module, "inflate", &pFinflate, inflateSlow);


  SET_MODULE(isolate, target, "zlib", module);
}
} // namespace zlib
} // namespace lo

extern "C" {
  void* _register_zlib() {
    return (void*)lo::zlib::Init;
  }
}
